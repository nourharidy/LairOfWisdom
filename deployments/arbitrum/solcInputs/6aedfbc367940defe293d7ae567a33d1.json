{
  "language": "Solidity",
  "sources": {
    "contracts/Dragon.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.6;\n\nimport \"./Lair.sol\";\nimport \"./Egg.sol\";\n\ncontract Dragon {\n\n    uint constant UPGRADE_COOLDOWN = 2 hours;\n    uint constant INIT_BREED_COOLDOWN = 1 days;\n    uint constant BREED_PROPOSAL_TIMEOUT = 7 days;\n    uint constant UPGRADE_FACTOR = 0.01 ether; // 1%\n    uint constant UPGRADE_COST = 5;\n    uint constant HEAL_COST = 1;\n    uint constant ATTACK_COST = 5; \n    uint constant BREED_COST = 10;\n    uint constant STATS_TIME_DECAY_DENOM = 10 minutes; // stats decay by 1% every 10 minutes\n\n    address public egg;\n    Lair public lair;\n    address[2] public parents;\n    string public name;\n    uint public breedCount;\n    uint lastUpgradeTimestamp;\n    uint lastAttackTimestamp;\n    uint lastBreedTimestamp;\n    uint lastPlayTimestamp;\n    uint lastFeedTimestamp;\n    uint lastCleanTimestamp;\n    uint lastSleepTimestamp;\n    uint public health = 1000000;\n    uint public maxHealth = 1000000;\n    uint public damage = 20000;\n    uint public attackCooldown = 1 hours;\n    uint public healthRegeneration = 2000;\n    uint8 hunger;\n    uint8 uncleanliness;\n    uint8 boredom;\n    uint8 sleepiness;\n    mapping (address => uint) public trust;\n    mapping (Dragon => mapping (string => uint)) public breedProposals;\n\n    constructor(address _egg, Lair _lair, address[2] memory _parents, string memory _name) {\n        egg = _egg;\n        lair = _lair;\n        parents = _parents;\n        name = _name;\n        lastUpgradeTimestamp = block.timestamp;\n        lastAttackTimestamp = block.timestamp;\n        lastPlayTimestamp = block.timestamp;\n        lastFeedTimestamp = block.timestamp;\n        lastCleanTimestamp = block.timestamp;\n        lastSleepTimestamp = block.timestamp;\n        lastBreedTimestamp = block.timestamp;\n    }\n\n    modifier IfAlive {\n        if(\n            getHunger() > 100 &&\n            getUncleanliness() > 100 &&\n            getBoredom() > 100 &&\n            getSleepiness() > 100) {\n                selfdestruct(payable(0)); // die\n            }\n        _;\n    }\n\n    modifier earnsTrust {\n        trust[msg.sender]++;\n        _;\n    } \n\n    modifier consumesTrust {\n        trust[msg.sender] -= UPGRADE_COST;\n        _;\n    }\n\n    /*\n        Healing\n    */\n\n    function heal() public IfAlive {\n        trust[msg.sender] -= HEAL_COST;\n        health = min(health + healthRegeneration, maxHealth);\n        emit Heal(msg.sender);\n    }\n\n    /*\n        Attack\n    */\n    function canAttack() public view returns (bool) {\n        return block.timestamp > lastAttackTimestamp + attackCooldown;\n    }\n\n    function secondsUntilAttack() public view returns (uint) {\n        if(canAttack()) return 0;\n        return block.timestamp - lastAttackTimestamp + attackCooldown;\n    }\n\n    function attack(Dragon target) public IfAlive {\n        require(canAttack(), \"i can only attack every so often\");\n        require(target != this, \"i can't attack myself\");\n        trust[msg.sender] -= ATTACK_COST;\n        require(lair.isDragon(target), \"target is not a dragon\");\n        require(isContract(address(target)), \"target dragon is dead\");\n        if(target.health() <= damage) { // target will die\n            maxHealth = target.maxHealth() / 4; // consume 1/4 maxHealth\n            damage = target.damage() / 4; // consume 1/4 damage\n        }\n        lastAttackTimestamp = block.timestamp;\n        target.onAttack();\n        emit Attack(msg.sender, address(target));\n    }\n\n    function onAttack() public {\n        Dragon attacker = Dragon(msg.sender);\n        require(lair.isDragon(attacker), \"attacker is not a dragon\");\n        if(health <= attacker.damage()) {\n            selfdestruct(payable(0)); // die\n        }\n        health -= attacker.damage();\n        emit Damaged(msg.sender);\n    }\n\n    /*\n        Breeding\n    */\n\n    function proposeBreeding(Dragon parent, string memory childName) public IfAlive {\n        trust[msg.sender] -= BREED_COST; // proposals also have cost\n        require(lair.isDragon(parent), \"parent is not a dragon\");\n        require(isContract(address(parent)), \"parent dragon is dead\");\n        require(parent != this, \"i can't breed with myself\");\n        require(bytes(childName).length > 0, \"my child must have a name\");\n        parent.onBreedProposal(childName);\n        emit ProposeBreed(msg.sender, address(parent), childName);\n    }\n\n    function onBreedProposal(string memory childName) public {\n        Dragon parent = Dragon(msg.sender);\n        require(lair.isDragon(parent), \"parent is not a dragon\");\n        breedProposals[parent][childName] = block.timestamp;\n        emit ReceiveBreedProposal(msg.sender, childName);\n    }\n\n    function canBreed() public view returns (bool) {\n        return block.timestamp > lastBreedTimestamp + (INIT_BREED_COOLDOWN * (2**(breedCount + 1)));\n    }\n\n    function secondsUntilBreed() public view returns (uint) {\n        if(canBreed()) return 0;\n        return block.timestamp - lastBreedTimestamp + (INIT_BREED_COOLDOWN * (2**(breedCount + 1)));\n    }\n\n    function breed(Dragon parent, string memory childName) public IfAlive returns (Egg _egg) {\n        trust[msg.sender] -= BREED_COST; // proposals also have cost\n        uint proposalTimestamp = breedProposals[parent][childName];\n        require(proposalTimestamp > 0, \"breed proposal does not exist\");\n        require(block.timestamp < proposalTimestamp + BREED_PROPOSAL_TIMEOUT, \"breed proposal expired\");\n        require(canBreed(), \"I can't breed yet\");\n        address[2] memory _parents = [address(this), address(parent)];\n        _egg = lair.fileEggCertificate(_parents, childName);\n        lastBreedTimestamp = block.timestamp;\n        breedProposals[parent][childName] = 0;\n        breedCount++;\n        emit Breed(msg.sender, address(parent), address(_egg), childName);\n    }\n\n    /*\n        Upgrades\n    */\n\n    function canUpgrade() public view returns (bool) {\n        return block.timestamp > lastUpgradeTimestamp + UPGRADE_COOLDOWN;\n    }\n\n    function secondsUntilUpgrade() public view returns (uint) {\n        if(canUpgrade()) return 0;\n        return block.timestamp - lastUpgradeTimestamp + UPGRADE_COOLDOWN;\n    }\n\n    function upgradeMaxHealth() public consumesTrust IfAlive {\n        require(canUpgrade(), \"i can only upgrade every so often\");\n        uint extraMaxHealth = maxHealth * UPGRADE_FACTOR / 1 ether;\n        maxHealth = maxHealth + extraMaxHealth;\n        lastUpgradeTimestamp = block.timestamp;\n        emit UpgradeMaxHealth(msg.sender);\n    }\n\n    function upgradeHealing() public consumesTrust IfAlive {\n        require(canUpgrade(), \"i can only upgrade every so often\");\n        uint extraHealPoints = healthRegeneration * UPGRADE_FACTOR / 1 ether;\n        healthRegeneration = healthRegeneration + extraHealPoints;\n        lastUpgradeTimestamp = block.timestamp;\n        emit UpgradeHealing(msg.sender);\n    }\n\n    function upgradeDamage() public consumesTrust IfAlive {\n        require(canUpgrade(), \"i can only upgrade every so often\");\n        uint addedDamage = damage * UPGRADE_FACTOR / 1 ether;\n        damage = damage + addedDamage;\n        lastUpgradeTimestamp = block.timestamp;\n        emit UpgradeDamage(msg.sender);\n    }\n\n    function upgradeAttackCooldown() public consumesTrust IfAlive {\n        require(canUpgrade(), \"i can only upgrade every so often\");\n        uint removedAttackCooldown = attackCooldown * UPGRADE_FACTOR / 1 ether;\n        attackCooldown = attackCooldown - removedAttackCooldown;\n        lastUpgradeTimestamp = block.timestamp;\n        emit UpgradeAttackCooldown(msg.sender);\n    }\n\n    /*\n        Caretaking\n    */\n\n    function feed() public earnsTrust IfAlive {\n        require(getHunger() > 50, \"i dont need to eat\");\n        require(getBoredom() < 80, \"im too tired to eat\");\n        require(getUncleanliness() < 80, \"im feeling too gross to eat\");\n        lastFeedTimestamp = block.timestamp;\n        \n        hunger = 0;\n        boredom += 10;\n        uncleanliness += 3;\n        emit Feed(msg.sender);\n    }\n\n    function clean() public earnsTrust IfAlive {\n        require(getUncleanliness() > 50, \"i dont need a bath\");\n        lastCleanTimestamp = block.timestamp;\n        \n        uncleanliness = 0;\n        emit Clean(msg.sender);\n    }\n\n    function play() public earnsTrust IfAlive {\n        require(getBoredom() > 50, \"i dont wanna play\");\n        require(getHunger() < 80, \"im too hungry to play\");\n        require(getSleepiness() < 80, \"im too sleepy to play\");\n        require(getUncleanliness() < 80, \"im feeling too gross to play\");\n        lastPlayTimestamp = block.timestamp;\n        \n        boredom = 0;\n        hunger += 10;\n        sleepiness += 10;\n        uncleanliness += 5;\n        emit Play(msg.sender);\n    }\n\n    function sleep() public earnsTrust IfAlive {\n        require(getSleepiness() > 50, \"im not feeling sleepy\");\n        require(getUncleanliness() < 80, \"im feeling too gross to sleep\");\n        \n        lastSleepTimestamp = block.timestamp;\n        \n        sleepiness = 0;\n        uncleanliness += 5;\n        emit Sleep(msg.sender);\n    }\n\n    function getHunger() public view returns (uint256) {\n        return hunger + ((block.timestamp - lastFeedTimestamp) / STATS_TIME_DECAY_DENOM);\n    }\n    \n    function getUncleanliness() public view returns (uint256) {\n        return uncleanliness + ((block.timestamp - lastCleanTimestamp) / STATS_TIME_DECAY_DENOM);\n    }\n    \n    function getBoredom() public view returns (uint256) {\n        return boredom + ((block.timestamp - lastPlayTimestamp) / STATS_TIME_DECAY_DENOM);\n    }\n    \n    function getSleepiness() public view returns (uint256) {\n        return sleepiness + ((block.timestamp - lastSleepTimestamp) / STATS_TIME_DECAY_DENOM);\n    }\n\n    /*\n        Utils\n    */\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    event Play(address indexed trainer);\n    event Feed(address indexed trainer);\n    event Sleep(address indexed trainer);\n    event Clean(address indexed trainer);\n    event Heal(address indexed trainer);\n    event UpgradeDamage(address indexed trainer);\n    event UpgradeAttackCooldown(address indexed trainer);\n    event UpgradeMaxHealth(address indexed trainer);\n    event UpgradeHealing(address indexed trainer);\n    event Attack(address indexed trainer, address indexed target);\n    event Damaged(address indexed attacker);\n    event ProposeBreed(address indexed trainer, address indexed parent, string childName);\n    event ReceiveBreedProposal(address indexed parent, string childName);\n    event Breed(address indexed trainer, address indexed parent, address egg, string childName);\n}"
    },
    "contracts/Lair.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.6;\n\nimport \"./Dragon.sol\";\nimport \"./Egg.sol\";\n\ncontract Lair {\n\n    Dragon[] public dragons;\n    mapping (Dragon => bool) public isDragon;\n\n    Egg[] public eggs;\n    mapping (Egg => bool) public isEgg;\n\n    constructor() {\n        address[2] memory parents = [address(0), address(0)];\n        Egg leshner = new Egg(this, parents, \"Leshner\");\n        eggs.push(leshner);\n        isEgg[leshner] = true;\n        emit EggBirth(address(leshner), parents[0], parents[1]);\n        Egg pleasr = new Egg(this, parents, \"Pleasr\");\n        eggs.push(pleasr);\n        isEgg[pleasr] = true;\n        emit EggBirth(address(pleasr), parents[0], parents[1]);\n    }\n\n    function fileDragonCertificate(address[2] memory parents, string memory name) external returns (Dragon dragon) {\n        require(isEgg[Egg(msg.sender)]);\n        dragon = new Dragon(msg.sender, this, parents, name);\n        dragons.push(dragon);\n        isDragon[dragon] = true;\n        emit DragonBirth(address(dragon), parents[0], parents[1]);\n    }\n\n    function fileEggCertificate(address[2] memory parents, string memory name) external returns (Egg egg)  {\n        require(isDragon[Dragon(msg.sender)]);\n        egg = new Egg(this, parents, name);\n        eggs.push(egg);\n        isEgg[egg] = true;\n        emit EggBirth(address(egg), parents[0], parents[1]);\n    }\n\n    event DragonBirth(address indexed dragon, address indexed parent1, address indexed parent2);\n    event EggBirth(address indexed dragon, address indexed parent1, address indexed parent2);\n}"
    },
    "contracts/Egg.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.6;\n\nimport \"./Lair.sol\";\nimport \"./Dragon.sol\";\n\ncontract Egg {\n\n    string public name;\n    uint constant BIRTH_DURATION = 12 hours;\n    address[2] public parents;\n    uint public creationTimestamp;\n    bool public born;\n    Lair public lair;\n    uint tributes;\n\n    constructor(Lair _lair, address[2] memory _parents, string memory _name) {\n        name = _name;\n        parents = _parents;\n        lair = _lair;\n        creationTimestamp = block.timestamp;\n    }\n\n    function isHatched() public view returns (bool) {\n        return block.timestamp > creationTimestamp + BIRTH_DURATION - tributes;\n    }\n\n    function secondsUntilHatched() public view returns (uint) {\n        if(isHatched()) {\n            return 0;\n        }\n\n        return block.timestamp - creationTimestamp + BIRTH_DURATION - tributes;\n    }\n\n    function getTributes() public view returns (uint) {\n        return tributes / 1000;\n    }\n\n    function giveTribute() public {\n        require(!isHatched(), \"im already hatched\");\n        if(tributes + 1000 <= BIRTH_DURATION) {\n            tributes += 1000;\n            emit Tribute(msg.sender);\n        }\n    }\n\n    function giveBirth() public returns (Dragon dragon) {\n        if(!born && isHatched()) {\n            dragon = lair.fileDragonCertificate(parents, name);\n            born = true;\n            emit Birth(msg.sender);\n        }\n    }\n\n    event Tribute(address indexed trainer);\n    event Birth(address indexed trainer);\n\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}